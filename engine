"""This program will simulate life on a cellular level simplisticly in order to test
various evolutionary and biological theories.
"""

import random
import string

"""WORLD represents the physical location of the cells. x = y
A list.
"""
WORLD = []
"""FOOD_WORLD represents the location of food that the cells
need to live.
A list.
"""
FOOD_WORLD = []
"""RECORD represents every cell that has ever lived.
It will track the cell's life span before it died.
A dictionary.
"""
RECORD = {}
"""CENSUS represents every cell that is currently alive.
It will keep track of the cell's X and Y coordinates.
A list.
"""
CENSUS = []
"""BOOK_OF_LIFE keeps a record of births and deaths.
It is a list
"""
BOOK_OF_LIFE = []

"""Functions that will do work."""
def id_generator(size=10, chars=string.digits):
    """Generates a 10 string ID of uppercase characters and integers
    unless given the arguments 1) the length 2) characters to choose from
    in generation. h/t to the internet.
    """
    return ''.join(random.choice(chars) for _ in range(size))

def census_input(cell):
    """Turns a cell's attributes into data that can be added to CENSUS."""
    census_input = [cell.id, [cell.x, cell.y]]
    return census_input

def one_fifty():
    """Returns a random number between 1 and 50."""
    num = random.randint(1,10)
    return num

def world_input(cell):
    "Turns a cell's attributes intos data that can be added to WORLD."""
    world_input = [cell.x, cell.y]
    return world_input

def plus_minus_same():
    """Returns 1,0, or -1 randomly."""
    coin = random.randint(0,2)
    if coin == 0:
        return -1
    elif coin == 1:
        return 0
    else:
        return 1

def coin_toss():
    """Simulates a coin toss."""
    coin = random.randint(0,1)
    if coin == 0:
        return 0
    else:
        return 1

def world_reset():
    """Will reset WORLD with only living cells from CENSUS."""
    del WORLD[:]
    for cell in CENSUS:
        WORLD.append([cell[1][0], cell[1][1]])

def read_book():
    for entry in BOOK_OF_LIFE:
        print(entry)

"""End of functions that do work."""

"""Classes that define entities."""
class Cell():
    """The unit of life for the simulation."""

    def __init__(self):
        """Creates a cell in limbo."""
        self.id = id_generator()
        self.life_span = 0
        self.food = 1
        self.mate = False
        self.mature = False
        RECORD[self.id] = 0

    def world_set(self,x=False,y=False):
        """Sets the cell on the world and gives it life."""
        self.alive = True
        self.life_span = 1
        if x == False:
            self.x = one_fifty()
        else:
            self.x = x
        if y == False:
            self.y = one_fifty()
        else:
            self.y = y
        RECORD[self.id] = 1
        """Starting location for cells is limbo, location determined
        by parents.
        """
        WORLD.append(world_input(self))
        CENSUS.append(census_input(self))

    def move_location(self,x,y):
        """Moves cell to new location in the world."""
        WORLD.remove(world_input(self))
        CENSUS.remove(census_input(self))
        self.x = x
        self.y = y
        WORLD.append(world_input(self))
        CENSUS.append(census_input(self))

    def food_adj(self,cost):
        """Gives or takes food from a cell."""
        CENSUS.remove(census_input(self))
        self.food += cost
        CENSUS.append(census_input(self))
        if self.food < 0:
            cell_death(cell)
            print('The cell %s has died due food expenditure.' % self.id)

"""End of classes that define entities."""

"""Biological Functions"""
def cell_death(cell):
    CENSUS.remove(census_input(cell))
    WORLD.remove(world_input(cell))
    cell.alive = False
    world_reset()
    
def mate_attempt(cell):
    """Function will attempt to mate called cell with all other applicable cells."""
    valid_mates = 0
    for other in CENSUS:
        """If cell is adjacent shares x but not y, or vice versa,
        they can mate.
        """
        if other[1][0] == cell.x:
            if other[1][1] == cell.y:
                pass
            else:
                valid_mates += 1
        """If the cell is adjacent in x and/or y they can mate."""
        if other[1][0] == (cell.x + 1) or other[0] == (cell.x -1):
            if other[1][1] == (cell.y + 1) or other[1][1] == (cell.y -1):
                valid_mates += 1
    """Self cell must have enough food."""
    if cell.food < 1:
        valid_mates = 0
    """Cells can only have four babies at maximum."""
    if valid_mates > 4:
        valid_mates = 4
    """Let's make baby cells now."""
    if valid_mates > 0:
        offspring_id = []
        """Loops through creating ID's for baby cells, costing food."""
        while True:
            for i in range(1,(valid_mates + 1)):
                offspring_id.append(id_generator())
                cell.food += -1
            break
        for baby in offspring_id:
            original_id = baby
            baby = Cell()
            baby.id = original_id
            baby_x = (cell.x + plus_minus_same())
            baby_y = (cell.y + plus_minus_same())
            baby.world_set(baby_x,baby_y)
            BOOK_OF_LIFE.insert(0,'%s was born on x: %s y: %s.' % (baby.id,baby.x,baby.y))
    if cell.food < 0:
        cell_death(cell)
        BOOK_OF_LIFE.insert(0,'%s died due to child birth.' % cell.id)

"""User command functions."""
def generation(first,food,num):
    """This function handles the successive generations of cells."""
    for item in range(1,(food+1)):
        """Create intitial food state."""
        FOOD_WORLD.append([one_fifty(),one_fifty()])
    cell_classes = []
    for cell in range(1,(first+1)):
            cell = Cell()
            cell_classes.append(cell)
            cell.world_set()
            BOOK_OF_LIFE.insert(0,'%s was born of the first generation at x: %s y: %s.' \
                                % (cell.id,cell.x,cell.y))
    """Goes through num generations."""
    times = 1
    for gen in range(1,(num+1)):
        if times > 1:
            for item in range(1,(food+1)):
                """Respawn food at random."""
                FOOD_WORLD.append([one_fifty(),one_fifty()])
        times += 1
        """Fight other's in their own square."""
        for cell in cell_classes:
            location = []
            location.append([cell.x,cell.y])
            for key in location:
                enemies = WORLD.count(key)
                enemy_list = []
                if enemies > 1:
                    for other in cell_classes:
                        if other.x == cell.x and other.y == cell.y:
                            enemy_list.append(other)
                            enemy_list.append(cell)
                            for enemy in enemy_list:
                                food_list = []
                                food_list.append(enemy.food)
                                winner = max(food_list)
                                if enemy.food == winner:
                                    victor = enemy
                                if enemy.food < winner:
                                    cell_death(enemy)
                                    BOOK_OF_LIFE.insert(0,'%s was killed by the competitor %s.' & (enemy,victor))
                                    world_reset()
                                if enemy.food == winner:
                                    coin = coin_toss()
                                    if coin == 0:
                                        if enemy.alive == True:
                                            cell_death(enemy)
                                            BOOK_OF_LIFE.insert(0,'%s was killed in a struggle for its environment.' \
                                                                % enemy.id)
                                            world_reset()
                            del enemy_list[:]
        """Hunt"""
        for cell in cell_classes:
            location = []
            location.append([cell.x,cell.y])
            for key in location:
                hunt = FOOD_WORLD.count(key)
                cell.food += hunt
            cell.food += -1
            if cell.food < 0 and cell.alive == True:
                cell_death(cell)
                BOOK_OF_LIFE.insert(0,'%s has died of starvation.' % cell.id)
            del FOOD_WORLD[:]
            for item in range(1,(food+1)):
                FOOD_WORLD.append([one_fifty(),one_fifty()])
        """Age the cells."""
        for cell in cell_classes:
            cell.life_span += 1
            RECORD[cell.id] = cell.life_span
            if cell.life_span == 2:
                cell.mature = True
    """Survivor check."""
    print("Survivors:")
    for cell in cell_classes:
        if cell.alive == True:
            print('Name: %s Lifespan: %s Food: %s' % (cell.id,cell.life_span,cell.food))
        
"""Copyright Patrick Morgan 2015, you may use, edit, and
distribute non-commercially. Made on the Raspberry Pi.
"""
